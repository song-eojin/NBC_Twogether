<h2>01. 프로젝트 소개</h2>

<h3>서비스 명: Twogether (Trello 클론 코딩)</h3>

 **Twogether는 Trello 클론 코딩 프로젝트로 협업 프로젝트 일정 관리를 지원하는 칸반 보드 서비스 입니다.**
 
  > [MVP 시연 영상](https://www.youtube.com/watch?v=sl1O1MEnIT8)
<br>

<h2>02. 기술 스택</h2>

<h6>back-end</h6>
<p style="display: block;">
    <img src="https://img.shields.io/badge/java-007396?style=for-the-badge&logo=java&amp;logoColor=white">
    <img src="https://img.shields.io/badge/MySQL-4479A1?style=for-the-badge&logo=MySQL&logoColor=white"/>
    <img src="https://img.shields.io/badge/H2-0000bb?style=for-the-badge&logo=H2&amp;logoColor=white">
    <img src="https://img.shields.io/badge/redis-%23DD0031.svg?style=for-the-badge&logo=redis&logoColor=white">
    <img src="https://img.shields.io/badge/Spring-6DB33F.svg?style=for-the-badge&logo=Spring&logoColor=white">
    <img src="https://img.shields.io/badge/Spring%20Boot-6DB33F.svg?style=for-the-badge&logo=Spring-Boot&logoColor=white">
    <img src="https://img.shields.io/badge/Spring%20Security-6DB33F.svg?style=for-the-badge&logo=Spring-Security&logoColor=white">
    <img src="https://img.shields.io/badge/Spring%20JPA-6DB33F.svg?style=for-the-badge&logo=Spring-JPA&logoColor=white">
    <img src="https://img.shields.io/badge/Spring%20JPA-6DB33F.svg?style=for-the-badge&logo=Spring-JPA&logoColor=white">
  </p>

<h6>front-end</h6>
  <p style="display: block;">
    <img src="https://img.shields.io/badge/html5-%23E34F26.svg?style=for-the-badge&logo=html5&logoColor=white">
    <img src="https://img.shields.io/badge/css3-%231572B6.svg?style=for-the-badge&logo=css3&logoColor=white">
    <img src="https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black"/>
    <img src="https://img.shields.io/badge/Thymeleaf-005F0F?style=for-the-badge&logo=Thymeleaf&logoColor=#005F0F">
  </p>

<h6>server</h6>
  <p style="display: block;">
    <img src="https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&logo=amazon-aws&logoColor=white">
    <img src="https://img.shields.io/badge/AWS EC2-f90?style=for-the-badge&logo=amazon-awsec2&logoColor=white">
    <img src="https://img.shields.io/badge/AWS CodeDeploy-f90?style=for-the-badge&logo=amazon-aws-CodeDeploy-f90&logoColor=gray">
    <img src="https://img.shields.io/badge/AWS RDS-f90?style=for-the-badge&logo=amazon-aws-RDS-f90&logoColor=blue">
    <img src="https://img.shields.io/badge/AWS S3-f90.svg?style=for-the-badge&logo=amazon-aws-S3&logoColor=green">
    <img src="https://img.shields.io/badge/AWS ElastiCache-f90.svg?style=for-the-badge&logo=ElastiCache&logoColor=red">    
  </p>

<h6>develop</h6>
  <p style="display: block;">
    <img src="https://img.shields.io/badge/GitHub-181717.svg?style=for-the-badge&logo=GitHub&logoColor=white">
    <img src="https://img.shields.io/badge/github%20actions-%232671E5.svg?style=for-the-badge&logo=githubactions&logoColor=white">
    <img src="https://img.shields.io/badge/Git-F05032.svg?style=for-the-badge&logo=Git&logoColor=white">
  </p>

<h6>tools</h6>
  <p style="display: block;">
    <img src="https://img.shields.io/badge/Swagger-85EA2D.svg?style=for-the-badge&logo=Swagger&logoColor=black">
    <img src="https://img.shields.io/badge/Notion-000000.svg?style=for-the-badge&logo=Notion&logoColor=white">
  </p>

<br>

 <h2>03. 팀 구성 및 업무 소개</h2>

| 팀 구성 | 역할  | 담당한 업무                                                                                                           |
|------|-----|------------------------------------------------------------------------------------------------------------------|
| 김희열  | 팀장  | - GithubAction CI/CD<br> - AWS 배포<br> - 테스트 코드 작성<br> - JWT와 Refresh Token을 활용한 인증/인가 방식 구현<br> - Redis를 활용한 이메일 인증 및 로그아웃 기능<br> - 사용자, 카드 댓글, 카드 라벨 CRUD |
| 한지훈  | 부팀장 | - 테스트 환경을 위한 JUnit5와 H2 데이터베이스 적용<br> - 더미 데이터 작성<br> - 테스트 코드 작성<br> - 카카오 소셜 로그인<br> - 덱, 카드
| 송어진  | 팀원  | - ApplicationEventPublisher를 통한 알림 기능<br> - 보드 초대/추방 기능<br> - 협업자 초대/추방 기능<br> - 사용자 프로필 기능<br> - 문서화 작업<br> - CSS 작업 보조                                                                           |
| 양소영  | 팀원  | - 워크스페이스, 카드 체크리스트<br> - 테스트 코드 작성<br> - 전반적인 CSS 작업                                                                  |

<br>

<h2>04. 서비스 아키텍처</h2>

![Twogether_Service_Architecture drawio](https://github.com/proLmpa/NBC_Twogether/assets/52267654/d76217fe-7709-4d4c-8ffd-b6cc910d8d82)
<br>

<h2>05. 기술적 의사결정</h2>

| 기술 스택 | 사용 이유 |
| --- | --- |
| JWT | 서버 메모리에 부담을 주지 않고 서버 확장에 용이한 인증/인가 방식 |
| h2 | 다양한 개발 환경에도 테스트 코드의 일관적인 성공을 보장할 수 있는 환경을 구축하기 위해 사용 |
| Redis | Refresh 토큰 및 이메일 인증 기능을 구현하기 위해 사용 |
| Github action | 코드의 지속적인 개발 / 서비스 제공 / 배포를 위한 일련의 CI/CD를 구현하기 위해 사용 |
| AWS CodeDeploy | Github Action으로 생성한 Build 파일을 생성 즉시 AWS에 자동으로 배포하기 위해 사용 |
| Thymeleaf | Java 템플릿 엔진으로 Front 구현을 위해 사용 |
| Swagger | API 문서화를 위해 사용 |

<br>

<h2>06. 트러블 슈팅</h2>

<details>
<summary>더미 데이터를 통한 테스트 코드 실행</summary>
<div markdown="1">
  <br>

* ❗문제 발생
    * 각 메서드를 실행할 때마다 발생하는 공통 로직이 존재하여 이를 @BeforeEach 로 각 메서드를 실행할 때마다 실행하고자 함.
    * 이를 해결하기 위해 기존에는 아래의 방식으로 데이터를 DB에 저장함.
    * 단일 인스턴스를 생성할 때야 편하지만 복수의 인스턴스를 생성해야 할 때는 코드의 길이가 길어지고 번잡해지는 문제를 발견함.
    * e.g. 보드 관련된 로직을 테스트하기 위해선 회원 가입과 워크스페이스 생성 작업이 사전에 이루어져야 한다.

          // UserServiceTest.java

          @BeforeEach
          void signUp() {
              // given
              String email = "user2024@email.com";
              String password = "user123!@#";
              boolean admin = false;
              String adminToken = "";
          
              encoder = new BCryptPasswordEncoder();
              SignupRequestDto request = SignupRequestDto.builder().email(email).password(password)
                  .admin(admin).adminToken(adminToken).build();
          
              // when
              User signed = userService.signup(request);
          
              // then
              Assertions.assertEquals(email, signed.getEmail());
              Assertions.assertTrue(encoder.matches(password, signed.getPassword()));
              Assertions.assertEquals(UserRoleEnum.USER, signed.getRole());
              user = signed;
          }

<br>

* ❓ 해결책 탐구
    * 더미 데이터 : 대용량 데이터를 테스트 실행 전에 준비할 필요가 있거나 연쇄적으로 매핑된 객체들을 순서대로 미리 만들어 놓기에 편리함.

<br>

* ➡️ 결과

    * 첫째, 테스트 전에 SQL을 통해 더미 데이터 생성하고, h2에 저장

             // data.sql
         
          	-- workspace 테이블 생성
          	CREATE TABLE IF NOT EXISTS workspace (
          	    id LONG PRIMARY KEY,
          	    title VARCHAR(50),
          	    icon VARCHAR(50),
          	    user_id LONG,
          	    created_at datetime,
          	    modified_at datetime,
          	    FOREIGN KEY (user_id) REFERENCES users(id)
          	);
          	
          	-- 더미 workspace 데이터 삽입
          	INSERT INTO workspace (id, title, icon, user_id, created_at, modified_at) VALUES
          	(1, 'Workspace 1', 'test', 1, '2023-01-01 00:00:00', '2023-01-01 00:00:00'),
          	(2, 'Workspace 2', 'test', 1, '2023-01-01 00:00:00', '2023-01-01 00:00:00'),
          	(3, 'Workspace 1', 'test', 2, '2023-01-01 00:00:00', '2023-01-01 00:00:00');

    * 둘째, 테스트 코드에서 더미 데이터 호출

              // BoardServiceTest.java

          		@BeforeEach
              void setUp() {
                  user = userRepository.findById(1L).orElse(null);
                  wp1 = wpRepository.findById(1L).orElse((null));
                  wp2 = wpRepository.findById(2L).orElse((null));
                  wp3 = wpRepository.findById(3L).orElse((null));
              }

</div>
</details>

<details>
<summary>CI/CD</summary>
<div markdown="1">

* ❗제안

    1. Github Actions로 빌드-테스트 자동화하는 CI를 구축한 것에서 더 나아가 배포 자동화까지 해보는 것이 좋을 것 같아 Githuh Actions를 통한 CD
       사용을 제안
    2. 배포를 담당할 서버가 AWS EC2 서비스라는 점에서 연동이 잘 되어 배포가 쉽고 빠른 AWS CodeDeploy 사용을 결정

<br>        

* ⛵ 적용 과정 <br>
    1. 파일이 배포될 AWS 서버 환경 준비
        - AWS EC2, RDS, ElastiCache 서비스 구매
        - 서버에 mysql, redis-cli, codedeploy-agent 등 필요한 서비스 설치
        - 각 서비스에 보안 그룹 및 IAM 역할 설정하기

    2. AWS CodeDeploy 설정
        - 배포 애플리케이션 및 배포 그룹 생성

    3. Github Actions CD 환경 준비
        - CD 환경을 위한 Github Actions secrets 추가
        - AWS CodeDeploy 배포를 위한 yml 파일 준비
        - AWS EC2가 배포 파일을 실행하도록 yml과 sh 파일 준비

  <br>            

* ➡️ 결과 : AWS CodeDeploy 적용 완료!
  <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/8ca5e5f3-4aac-4fb9-af96-7e54d7ecaf10">

  <br>            

</div>
</details>

<details>
<summary>Lazy Loading 방식</summary>
<div markdown="1">

* ❗문제 발생
  : 보드 협업자로 초대된 경우, 자동으로 워크스페이스 협업자로도 등록하는 로직에서 `WorkspaceCollaborator DB(워크스페이스 협업자)`에 데이터가 담기지 않는
  문제 발생

        // 문제가 발생한 코드
        
            public void autoInviteWpCol(User user, Long wpId) {
                Workspace foundWorkspace = findWpById(wpId);
        
                // 이미 등록된 사용자 초대당하기 불가
                if (wpColRepository.existsByWorkspaceAndEmail(foundWorkspace, user.getEmail())) {
                    throw new CustomException(CustomErrorCode.WORKSPACE_COLLABORATOR_ALREADY_EXISTS);
                }
        
                // 워크스페이스 협업자로 등록
                User invitedUser = findUser(user.getEmail());
                WorkspaceCollaborator newWpCol = WpColRequestDto.toEntity(invitedUser, foundWorkspace);
        
                // 아이디 수동 할당 - 데이터가 덮어 씌어지는 문제 방지
                newWpCol.assignNewId();
                wpColRepository.save(newWpCol);
            }

<br>    

* ❓해결책 탐구
    * `의심 01.` <br>아래의 코드에서 foundWorkspace 변수와 invitedUser 변수의 필드에 null 값이 담기고, $$_
      hibernate_interceptor 안에 실제 데이터가 담기는 현상이 발생했다. <br>우선 Hibernate Interceptor가 무엇인지 알아보았다.
      Hibernate가 엔티티의 상태를 추적하고 데이터베이스 작업 전/후에 사용자 정의 로직을 실행하는 역할을 한다고 한다. 현 문제 상황과 연관이 있을 가능성이 높아
      보이지는 않는다..!

  <br>

    * `의심 02.` Lazy Loading과 관련된 문제일 수 있다는 가정 하에 해결책을 탐구하기 시작했다. 우선 Lazy Loading은 연관된 엔티티를 필요한 시점에
      데이터베이스에서 로드 하는 방식으로, 현 문제 상황과 관련이 있을 지도 모른다고 생각한 이유는 다음과 같다.<br>둘의 연관성을 살펴보면.. JPA Entity를
      로드할 때 연관된 엔티티를 FetchType.LAZY로 설정한 경우, FetchType.LAZY로 설정된 연관 엔티티는 실제로 필요한 시점에 데이터베이스에서 가져오기
      때문에 해당 필드에 접근이 생기기 전에는 초기화되지 않는다.<br>즉, Lazy Loading 방식을 사용하면 JPA는 연관 관계를 맺고 있는 Workspace
      Collaborator db에 접근하는 것을 지연시키고..<br>이로 인해, workspace를 통해 연관된 엔티티를 거쳐서 wpColRepository에 직접
      user를 save 시키더라도, workspace와 연관 관계를 맺고 있는 WorkspaceCollaborator 필드에 접근하는 로직이 없어서, Lazy
      Loading에 의해 WorkspaceCollaborator db 접근이 지연될 수 있을 거라 생각한 것이다.

<br>

* ✅ 문제 확인 <br>Lazy Loading 방식을 사용하면 JPA는 연관 관계를 맺고 있는 WorkspaceCollaborator DB에 접근하는 것을 지연시킨다.

<br>

* 💡 첫 번째 해결 방법 :  `Eager Loading 방식으로 바꾸기`

  최종적으로 워크스페이스 협업자를 DB에 저장하고 싶은 것이므로, Workspace를 통해 연관 Entity인 WorkspaceCollaborator를 즉시 로드할 수 있도록
  Eager Loading 방식을 사용하였다.

        // 수정한 코드

        @Builder
        @Entity
        @Getter
        @NoArgsConstructor
        @AllArgsConstructor
        public class Workspace extends Timestamped {
                       .
                       .
                       .
            @Builder.Default
            @OneToMany(mappedBy = "workspace", fetch = FetchType.EAGER)
            private List<WorkspaceCollaborator> workspaceCollaborators = new ArrayList<>();
        
        성공적으로 DB에 협업자가 등록된다!
        <img src="https://github.com/song-eojin/song-eojin.github.io/assets/122079064/b3f78952-a6ab-46d7-bf95-d02421a374c4">


* ⚠️ 첫 번째 해결방법의 문제점<br> : 위와 같이 WorkspaceCollaborator Entity를 Eager Loading 방식으로 설정했을
  때 `JPA N+1 문제`로 인한 성능 이슈가 발생할 수 있다.<br>즉, 하나의 Workspace만 조회를 해도 각각의 Workspace가 가진
  WorkspaceCollaborator 모두를 조회하는 것이다.

<br>

* 💡 두 번째 해결책 : `JPQL의 JOIN FETCH 및 Fetch Join 전략 사용하기`

  연관 엔티티와 함께 현재 엔티티를 로딩함으로, Lazy Loading 방식을 사용하면서
  발생한 `WorkspaceCollaborator DB에 접근하는 것을 지연되어 협업 멤버가 DB에 Save되지 않는 문제`를 해결할 수 있다.

  다소 쿼리 문이 복잡해질 가능성이 있지만 우리가 직면한 상황에서는 이것이 문제가 되지는 않는다.

        public Workspace findWpById(Long wpId) {
            return wpRepository.findByIdWithCollaborators(wpId).orElseThrow(() ->
                new CustomException(CustomErrorCode.WORKSPACE_NOT_FOUND));
        }

  뿐만 아니라 Eager Loading 방식을 사용하였을 때 발생하는 불필요한 데이터까지 로딩되는 문제, 그리고 아래와 같이 JOIN을 통해 하나의 쿼리 문으로 작동하기 때문에
  N+1 쿼리 문제까지 해결이 된다.

        SELECT w FROM Workspace w
        JOIN FETCH w.workspaceCollaborators
        WHERE w.id = :wpId


* 💡 세 번째 해결책 : `Lazy Loading 방식을 사용하면서 Transaction 내에서 필드에 접근하기`

        성능을 높이기 위해 필요한 경우에만 데이터를 로드하는 Lazy Loading 방식을 유지하면서, workspaceCollaborator 필드에 접근하는 로직 추가하면 어떨까?
        
        // 수정한 코드
        @Builder
        @Entity
        @Getter
        @NoArgsConstructor
        @AllArgsConstructor
        public class Workspace extends Timestamped {
                       .
                       .
                       .
            @Builder.Default
            @OneToMany(mappedBy = "workspace") // default가 LAZY
            private List<WorkspaceCollaborator> workspaceCollaborators = new ArrayList<>();
                       .
                       .
                       .
            // Lazy Loading을 강제로 발생시켜 workspaceCollaborator 필드를 로드하는 메서드
            public List<WorkspaceCollaborator> loadWorkspaceCollaborators() {
                if (this.workspaceCollaborators == null) {
                    // Lazy Loading을 발생시키기 위해 size() 메서드를 호출
                    this.workspaceCollaborators.size();
                }
                return this.workspaceCollaborators;
            }
        }

  loadWorkspaceCollaborators 메서드 호출이 Lazy Loading을 강제로 발생시켜 데이터베이스에서 연관된 workspaceCollaborators 정보를
  로드하고 성공적으로 workspaceCollaborator db에 접근할 수 있게 된다.

        @Service
        @RequiredArgsConstructor
        public class WpColService {
                                     .
                                     .
                                     .
            public void autoInviteWpCol(User user, Long wpId) {
                Workspace foundWorkspace = findWpById(wpId);
        
                // workspaceCollaborators 필드를 로드하여 Lazy Loading을 강제로 발생시키기
                foundWorkspace.loadWorkspaceCollaborators();
        
                // 이미 등록된 사용자 초대당하기 불가
                if (wpColRepository.existsByWorkspaceAndEmail(foundWorkspace, user.getEmail())) {
                    throw new CustomException(CustomErrorCode.WORKSPACE_COLLABORATOR_ALREADY_EXISTS);
                }
        
                // 워크스페이스 협업자로 등록
                User invitedUser = findUser(user.getEmail());
                WorkspaceCollaborator newWpCol = WpColRequestDto.toEntity(invitedUser, foundWorkspace);
        
                // 아이디 수동 할당 - 데이터가 덮어 씌어지는 문제 방지
                newWpCol.assignNewId();
                wpColRepository.save(newWpCol);
            }

<br>

* ⚠️ 고민<br>
  연관 엔티티를 단순히 저장하고자 하는 상황에서 Fetch Join 방식과 Transaction 내에서 필드에 접근하여 데이터를 로드하는 방식 중 무엇이 더 우리 프로젝트에
  적합한 방법일까?<br>둘의 차이점은 코드가 실행되는 위치가 다르다는 것이다.<br>우선 Fetch Join 방식은 데이터 레벨에서 동작하며 속도가 빠르다는
  장점이 있다. 반면, 트랜잭션 내 필드 접근을 통한 Lazy Loading 방식은 JVM에서 동작한다는 차이가 있다.

<br>

* ➡️ 결론<br>
  첫째, 연관 엔티티를 단순히 저장하는 행위는 빠른 처리 속도가 필요하지 않다.<br>
  둘째, 우리 프로젝트는 추후 작업될 동시성 문제와 관련하여 프로젝트의 전체적인 처리 속도가 중요하므로, 다른 작업에서는 최대한 데이터베이스에 부하를 주지 않는 것이
  좋다.<br>Lazy Loading 방식을 사용함으로써 발생한 문제를 해결하기 위해, 앞선 두 가지 논거를 들어 세 번째 해결 방법에 해당하는 트랜잭션 내 필드 접근을
  통한 방식을 사용하겠다는 결론을 내렸다.

  <br>

</div>
</details><br>

<h2>07. 참고 자료</h2>

 - [ERD 설계도](https://lucid.app/lucidchart/4e8d77af-15fc-4881-8e63-8660d4cc2ca1/edit?viewport_loc=96%2C1016%2C1993%2C759%2C0_0&invitationId=inv_2d63d1c6-2b26-4ead-9180-ff600668fd08)
 - [API 설계도](http://www.twogetherwork.com/swagger-ui/index.html)
 <br>
